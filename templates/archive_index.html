{% extends "layout.html" %}

{% block title %}Daily {{ category_display_name }} Archive{% endblock %}

{% block extra_css %}{% endblock %}

{% block content %}
<div class="page-header header-with-search">
    <div class="header-titles">
        <p class="eyebrow">Archive</p>
        <h1>{{ category_display_name }} 뉴스 아카이브</h1>
    </div>
    <form class="search-bar header-search" id="archive-search-form">
        <input type="text" id="archive-search-input" placeholder="검색어를 입력하세요" aria-label="기사 검색">
        <button type="submit" class="primary-btn">여기서 검색</button>
    </form>
</div>

{% if run_entries %}
<section class="search-section-container">
    <div id="search-results-section" class="search-results hidden card">
        <div class="section-heading compact">
            <div>
                <p class="eyebrow">검색 결과</p>
                <h4 id="search-result-title"></h4>
            </div>
            <div class="pill" id="search-count"></div>
            <button type="button" id="search-reset" class="ghost-btn subtle">검색 닫기</button>
        </div>
        <div id="search-results-grid" class="news-grid"></div>
    </div>
</section>

<section class="calendar-section card">
    <div class="section-heading">
        <div>
            <p class="eyebrow">날짜별 아카이브</p>
        </div>
        <div id="popover-run-list" class="popover-list"></div>
    </div>
    <div class="calendar-nav">
        <button id="prev-month" class="ghost-btn" aria-label="이전 달 보기">←</button>
        <div id="current-month-label" class="month-label"></div>
        <button id="next-month" class="ghost-btn" aria-label="다음 달 보기">→</button>
    </div>
    <div id="run-popover" class="run-popover hidden" role="dialog" aria-modal="false"
        aria-labelledby="popover-date-label">
        <div class="popover-header">
            <div>
                <p class="eyebrow">회차 선택</p>
                <h4 id="popover-date-label"></h4>
            </div>
            <button type="button" class="ghost-btn" id="popover-close" aria-label="회차 선택 닫기">✕</button>
        </div>
        <div id="popover-run-list" class="popover-list"></div>
    </div>
    <div id="calendar-container" class="calendar-container"></div>
</section>

<section class="today-section card">
    <div class="section-heading">
        <div>
            <p class="eyebrow">오늘 뉴스</p>
            <h2 id="selected-date-label"></h2>
            <p class="subtitle" id="selected-time-label"></p>
        </div>
        <div class="pill" id="selected-count"></div>
    </div>
    <div id="today-news-grid" class="news-grid today-grid">
        <p class="empty-msg">뉴스를 불러오는 중입니다...</p>
    </div>
</section>

<script>
    const runEntries = {{ run_entries | tojson | safe }};
    const runsByDate = {};
    const todayGrid = document.getElementById('today-news-grid');
    const dateLabel = document.getElementById('selected-date-label');
    const timeLabel = document.getElementById('selected-time-label');
    const countLabel = document.getElementById('selected-count');
    const calendarContainer = document.getElementById('calendar-container');
    const monthLabel = document.getElementById('current-month-label');
    const prevMonthBtn = document.getElementById('prev-month');
    const nextMonthBtn = document.getElementById('next-month');
    const searchForm = document.getElementById('archive-search-form');
    const searchInput = document.getElementById('archive-search-input');
    const searchSection = document.getElementById('search-results-section');
    const searchGrid = document.getElementById('search-results-grid');
    const searchTitle = document.getElementById('search-result-title');
    const searchCount = document.getElementById('search-count');
    const searchReset = document.getElementById('search-reset');
    const calendarCard = document.querySelector('.calendar-section');
    const todayCard = document.querySelector('.today-section');

    const articleCache = {};
    const holidayCache = {};
    let monthKeys = [];
    let currentMonthIndex = 0;
    let activeDate = '';
    let dateArticleTotals = {};

    function parseDateSafe(value) {
        if (!value) return null;
        const normalized = value.replace(/\./g, '-');
        const parsed = new Date(normalized);
        return isNaN(parsed) ? null : parsed;
    }

    function sortArticlesByPublished(articles) {
        return [...articles].sort((a, b) => {
            const da = parseDateSafe(a.published);
            const db = parseDateSafe(b.published);
            if (da && db) return db - da;
            if (db) return 1;
            if (da) return -1;
            return 0;
        });
    }

    function parseRunDateTime(run) {
        if (!run?.date_str) return 0;
        const timePart = run.time_str?.length ? run.time_str : '00:00';
        const parsed = new Date(`${run.date_str}T${timePart}`);
        if (!isNaN(parsed)) return parsed.getTime();
        const fallback = new Date(run.date_str);
        return isNaN(fallback) ? 0 : fallback.getTime();
    }

    function sortRunEntries() {
        runEntries.sort((a, b) => parseRunDateTime(b) - parseRunDateTime(a));
    }

    function buildRunMap() {
        sortRunEntries();

        runEntries.forEach((run, idx) => {
            run.absolute_index = idx;
            const list = runsByDate[run.date_str] || [];
            list.push(run);
            runsByDate[run.date_str] = list;
        });

        Object.values(runsByDate).forEach(list => {
            list.sort((a, b) => (a.time_str < b.time_str ? 1 : -1));
        });

        const uniqueMonths = new Set();
        Object.keys(runsByDate).forEach(dateStr => {
            const key = getMonthKey(dateStr);
            if (key) uniqueMonths.add(key);
        });

        monthKeys = Array.from(uniqueMonths).sort((a, b) => {
            const [ay, am] = a.split('-').map(Number);
            const [by, bm] = b.split('-').map(Number);
            if (ay !== by) return ay - by;
            return am - bm;
        });
        currentMonthIndex = monthKeys.length ? monthKeys.length - 1 : 0;
    }

    function updateDateTotals() {
        dateArticleTotals = {};
        runEntries.forEach(run => {
            const key = run.date_str;
            if (!key) return;
            const current = dateArticleTotals[key] || 0;
            dateArticleTotals[key] = current + (run.article_count || 0);
        });
    }

    function formatDateLabel(dateStr) {
        const parts = dateStr.split('-');
        if (parts.length !== 3) return dateStr;
        return `${parts[0]}년 ${Number(parts[1])}월 ${Number(parts[2])}일`;
    }

    function getKoreanHolidays(year) {
        if (!year) return new Set();
        if (holidayCache[year]) return holidayCache[year];

        const fixed = [
            `${year}-01-01`, // 새해 첫날
            `${year}-03-01`, // 삼일절
            `${year}-05-05`, // 어린이날
            `${year}-06-06`, // 현충일
            `${year}-08-15`, // 광복절
            `${year}-10-03`, // 개천절
            `${year}-10-09`, // 한글날
            `${year}-12-25`  // 성탄절
        ];

        const lunarBased = {
            2023: ['2023-01-21', '2023-01-22', '2023-01-23', '2023-01-24', '2023-05-27', '2023-09-28', '2023-09-29', '2023-09-30'],
            2024: ['2024-02-09', '2024-02-10', '2024-02-11', '2024-02-12', '2024-05-15', '2024-09-16', '2024-09-17', '2024-09-18'],
            2025: ['2025-01-28', '2025-01-29', '2025-01-30', '2025-01-31', '2025-05-05', '2025-10-06', '2025-10-07', '2025-10-08']
        };

        const holidays = new Set([...fixed, ...(lunarBased[year] || [])]);
        holidayCache[year] = holidays;
        return holidays;
    }

    function isKoreanHoliday(dateStr) {
        const [year] = dateStr.split('-').map(Number);
        if (!year) return false;
        return getKoreanHolidays(year).has(dateStr);
    }

    function getMonthKey(dateStr) {
        const dateObj = new Date(dateStr + 'T00:00:00');
        if (isNaN(dateObj)) return '';
        return `${dateObj.getFullYear()}-${dateObj.getMonth()}`;
    }

    function formatMonthLabel(key) {
        const [year, month] = key.split('-').map(Number);
        if (isNaN(year) || isNaN(month)) return '';
        return `${year}년 ${month + 1}월`;
    }

    function createNewsCard(article, extraMetaParts = []) {
        const card = document.createElement('article');
        card.className = 'news-item'; // Use standard class

        // 1. Header Section
        const header = document.createElement('div');
        header.className = 'news-header';

        const title = document.createElement('h3'); // or h2 to match main list, but h3 is fine for search results
        title.className = 'news-title';
        const link = document.createElement('a');
        link.href = article.link;
        link.target = '_blank';
        link.textContent = article.title;
        title.appendChild(link);

        const meta = document.createElement('div');
        meta.className = 'news-meta';
        const metaParts = [...extraMetaParts];
        if (article.source) metaParts.push(`<span class='source-link'>${article.source}</span>`);
        if (article.published) metaParts.push(article.published);
        meta.innerHTML = metaParts.join(' · '); // Use innerHTML to allow span

        header.appendChild(title);
        header.appendChild(meta);
        card.appendChild(header);

        // 2. Body Section (Image + Summary side-by-side)
        const body = document.createElement('div');
        body.className = 'news-body';

        if (article.image) {
            const thumb = document.createElement('div');
            thumb.className = 'news-image'; // Use standard class
            const img = document.createElement('img');
            img.src = article.image;
            img.alt = 'thumbnail';
            img.loading = 'lazy';
            thumb.appendChild(img);
            body.appendChild(thumb);
        }

        const summary = document.createElement('div');
        summary.className = 'news-summary';
        summary.innerHTML = article.summary;
        body.appendChild(summary);

        card.appendChild(body);

        return card;
    }

    function renderNewsCards(container, articles, metaPartsFactory = () => [], emptyMessage = '결과가 없습니다.') {
        container.innerHTML = '';
        if (!articles.length) {
            container.innerHTML = `<p class="empty-msg">${emptyMessage}</p>`;
            return;
        }

        articles.forEach((article, idx) => {
            const card = createNewsCard(article, metaPartsFactory(article, idx));
            container.appendChild(card);
        });
    }

    function updateTodayHeader(articles, run) {
        dateLabel.textContent = `${formatDateLabel(run.date_str)} (${run.day_of_week})`;
        timeLabel.textContent = run.time_str ? `${run.time_str} 생성됨` : '';
        countLabel.textContent = `${articles.length}개 기사`;
    }

    async function fetchRunArticles(run) {
        if (articleCache[run.filename]) return articleCache[run.filename];

        const response = await fetch(`daily/${run.filename}`);
        const html = await response.text();
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const articles = Array.from(doc.querySelectorAll('.news-item')).map(item => ({
            title: item.querySelector('.news-title a')?.textContent?.trim() || '제목 없음',
            link: item.querySelector('.news-title a')?.getAttribute('href') || '#',
            summary: item.querySelector('.news-summary')?.innerHTML || '',
            source: item.querySelector('.news-meta .source-link')?.textContent?.trim() || '',
            published: item.querySelector('.news-meta .published-date')?.textContent?.trim() || '',
            image: item.querySelector('.news-image img')?.getAttribute('src') || ''
        }));

        const sortedArticles = sortArticlesByPublished(articles);
        articleCache[run.filename] = { articles: sortedArticles, run };
        run.article_count = articles.length;
        return articleCache[run.filename];
    }

    async function prefetchArticleCounts() {
        await Promise.all(
            runEntries.map(async (run) => {
                const { articles } = await fetchRunArticles(run);
                run.article_count = articles.length;
            })
        );
    }

    async function loadRun(dateStr, runIndex = 0) {
        const runList = runsByDate[dateStr];
        if (!runList || !runList[runIndex]) return;

        const run = runList[runIndex];
        todayGrid.innerHTML = '<p class="empty-msg">뉴스를 불러오는 중입니다...</p>';

        try {
            const { articles } = await fetchRunArticles(run);
            renderNewsCards(todayGrid, articles, () => [], '이 날짜에는 뉴스가 없습니다.');
            updateTodayHeader(articles, run);
            highlightActive(run.date_str);
        } catch (err) {
            todayGrid.innerHTML = `<p class="empty-msg">뉴스를 불러오지 못했습니다: ${err}</p>`;
        }
    }

    function renderCalendar() {
        const key = monthKeys[currentMonthIndex];
        calendarContainer.innerHTML = '';
        monthLabel.textContent = key ? formatMonthLabel(key) : '';

        if (!key) {
            calendarContainer.innerHTML = '<p class="empty-msg">캘린더 데이터를 찾을 수 없습니다.</p>';
            return;
        }

        const [year, month] = key.split('-').map(Number);
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);

        const monthBlock = document.createElement('div');
        monthBlock.className = 'month-block';

        const weekdayRow = document.createElement('div');
        weekdayRow.className = 'weekday-row';
        ['월', '화', '수', '목', '금', '토', '일'].forEach((d, idx) => {
            const wd = document.createElement('div');
            wd.textContent = d;
            if (idx >= 5) {
                wd.classList.add('weekend');
            }
            weekdayRow.appendChild(wd);
        });
        monthBlock.appendChild(weekdayRow);

        const grid = document.createElement('div');
        grid.className = 'calendar-grid';

        const offset = (firstDay.getDay() + 6) % 7; // 월요일 시작 기준 오프셋
        for (let i = 0; i < offset; i++) {
            grid.appendChild(document.createElement('div'));
        }

        for (let day = 1; day <= lastDay.getDate(); day++) {
            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const cell = document.createElement('div');
            cell.className = 'calendar-cell';
            cell.dataset.date = dateStr;

            const dayOfWeek = new Date(dateStr + 'T00:00:00').getDay();
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
            const isHoliday = isKoreanHoliday(dateStr);
            if (isWeekend) cell.classList.add('weekend');
            if (isHoliday) cell.classList.add('holiday');

            const dateLabel = document.createElement('button');
            dateLabel.type = 'button';
            dateLabel.className = 'cell-date';
            dateLabel.textContent = day;

            const header = document.createElement('div');
            header.className = 'cell-header';
            header.appendChild(dateLabel);

            const runs = runsByDate[dateStr];
            const hasRuns = runs && runs.length;
            if (hasRuns) {
                cell.classList.add('has-articles');
                const runCount = document.createElement('div');
                runCount.className = 'run-count';
                const totalArticles = dateArticleTotals[dateStr];
                runCount.textContent = typeof totalArticles === 'number' && totalArticles > 0 ? totalArticles : 0;
                runCount.setAttribute('aria-label', `${totalArticles || 0}개 기사`);
                header.appendChild(runCount);
                cell.addEventListener('click', () => handleDateSelection(dateStr));
            } else {
                cell.classList.add('empty');
            }

            cell.appendChild(header);
            grid.appendChild(cell);
        }

        monthBlock.appendChild(grid);
        calendarContainer.appendChild(monthBlock);
        highlightActive(activeDate);
    }

    function highlightActive(dateStr) {
        activeDate = dateStr;
        document.querySelectorAll('.calendar-cell').forEach(cell => cell.classList.remove('active'));
        const selector = `.calendar-cell[data-date="${dateStr}"]`;
        const target = document.querySelector(selector);
        if (target) target.classList.add('active');
    }

    function changeMonth(delta) {
        const nextIndex = currentMonthIndex + delta;
        if (nextIndex < 0 || nextIndex >= monthKeys.length) return;
        currentMonthIndex = nextIndex;
        renderCalendar();
    }

    async function handleDateSelection(dateStr) {
        const runs = runsByDate[dateStr];
        if (!runs || !runs.length) return;

        if (typeof runs[0].article_count !== 'number') {
            const { articles } = await fetchRunArticles(runs[0]);
            runs[0].article_count = articles.length;
            updateDateTotals();
            renderCalendar();
        }

        return loadRun(dateStr, 0);
    }

    function exitSearchMode() {
        searchSection.classList.add('hidden');
        searchGrid.innerHTML = '';
        searchTitle.textContent = '';
        searchCount.textContent = '';
        searchInput.value = '';
        calendarCard.classList.remove('hidden');
        todayCard.classList.remove('hidden');
        history.replaceState({}, '', window.location.pathname);
    }

    function stripHtml(html) {
        const temp = document.createElement('div');
        temp.innerHTML = html;
        return temp.textContent || '';
    }

    async function handleSearch(event) {
        event.preventDefault();
        const keyword = searchInput.value.trim();

        if (!keyword) {
            exitSearchMode();
            return;
        }

        const normalized = keyword.toLowerCase();
        searchSection.classList.remove('hidden');
        searchGrid.innerHTML = '<p class="empty-msg">검색 중입니다...</p>';
        searchTitle.textContent = `"${keyword}" 검색 결과`;
        calendarCard.classList.add('hidden');
        todayCard.classList.add('hidden');
        history.pushState({ searching: true }, '', '#search');

        const matches = [];
        for (const run of runEntries) {
            const { articles } = await fetchRunArticles(run);
            articles.forEach(article => {
                const haystack = `${article.title} ${stripHtml(article.summary)}`.toLowerCase();
                if (haystack.includes(normalized)) {
                    matches.push({ article, run });
                }
            });
        }

        searchCount.textContent = `${matches.length}건`;
        if (!matches.length) {
            searchGrid.innerHTML = '<p class="empty-msg">일치하는 기사가 없습니다.</p>';
            return;
        }

        searchGrid.innerHTML = '';
        matches.forEach(({ article, run }) => {
            const card = createNewsCard(article, [formatDateLabel(run.date_str), run.time_str]);
            searchGrid.appendChild(card);
        });
    }

    async function initArchivePage() {
        buildRunMap();
        await prefetchArticleCounts();
        updateDateTotals();
        renderCalendar();
        const newest = runEntries[0];
        if (newest) {
            loadRun(newest.date_str, 0);
        }
    }

    initArchivePage();

    prevMonthBtn.addEventListener('click', () => changeMonth(-1));
    nextMonthBtn.addEventListener('click', () => changeMonth(1));
    searchForm.addEventListener('submit', handleSearch);
    searchReset.addEventListener('click', exitSearchMode);
    window.addEventListener('popstate', (event) => {
        if (!event.state || !event.state.searching) {
            exitSearchMode();
        }
    });
</script>
{% else %}
<div class="empty-msg">아직 발행된 뉴스가 없습니다.</div>
{% endif %}
{% endblock %}